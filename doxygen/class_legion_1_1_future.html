<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Legion Runtime: Legion::Future Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Legion Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_legion.html">Legion</a></li><li class="navelem"><a class="el" href="class_legion_1_1_future.html">Future</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_legion_1_1_future-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Legion::Future Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="legion_8h_source.html">legion.h</a>&gt;</code></p>

<p>Inherits Legion::Unserializable&lt; T &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10a3d3e23bd7c52825311dc88762236a"><td class="memItemLeft" align="right" valign="top"><a id="a10a3d3e23bd7c52825311dc88762236a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f)</td></tr>
<tr class="separator:a10a3d3e23bd7c52825311dc88762236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12d5732743bcd588960bae1b85937f4"><td class="memItemLeft" align="right" valign="top"><a id="ab12d5732743bcd588960bae1b85937f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f) const</td></tr>
<tr class="separator:ab12d5732743bcd588960bae1b85937f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ef3cefe9296e112906ce7683c3f16a"><td class="memItemLeft" align="right" valign="top"><a id="aa4ef3cefe9296e112906ce7683c3f16a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f) const</td></tr>
<tr class="separator:aa4ef3cefe9296e112906ce7683c3f16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9fdbf419203ec480f2dc4af4280f86"><td class="memItemLeft" align="right" valign="top"><a id="a6d9fdbf419203ec480f2dc4af4280f86"></a>
<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f)</td></tr>
<tr class="separator:a6d9fdbf419203ec480f2dc4af4280f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d6f6ad66bcd8dbccd34205d758c572"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86d6f6ad66bcd8dbccd34205d758c572"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a86d6f6ad66bcd8dbccd34205d758c572">get_result</a> (bool silence_warnings=false) const</td></tr>
<tr class="separator:a86d6f6ad66bcd8dbccd34205d758c572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78f1556f5d5ef988aea56f5a2aaba52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#af78f1556f5d5ef988aea56f5a2aaba52">get_void_result</a> (bool silence_warnings=false) const</td></tr>
<tr class="separator:af78f1556f5d5ef988aea56f5a2aaba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75721ea98fd87fc454f657d5651407e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a75721ea98fd87fc454f657d5651407e0">is_empty</a> (bool block=false, bool silence_warnings=false) const</td></tr>
<tr class="separator:a75721ea98fd87fc454f657d5651407e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7a29669acc4318532869600dd15a52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb7a29669acc4318532869600dd15a52"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#afb7a29669acc4318532869600dd15a52">get_reference</a> (bool silence_warnings=false)</td></tr>
<tr class="separator:afb7a29669acc4318532869600dd15a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9073b0ea27ef17c90ca1c8c578484b26"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a9073b0ea27ef17c90ca1c8c578484b26">get_untyped_pointer</a> (bool silence_warnings=false)</td></tr>
<tr class="separator:a9073b0ea27ef17c90ca1c8c578484b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334c6926a0611e1f38de5402de58eee0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a334c6926a0611e1f38de5402de58eee0">get_untyped_size</a> (void)</td></tr>
<tr class="separator:a334c6926a0611e1f38de5402de58eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2261502adba46d36318c7756abc16ff1"><td class="memTemplParams" colspan="2"><a id="a2261502adba46d36318c7756abc16ff1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2261502adba46d36318c7756abc16ff1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (void)</td></tr>
<tr class="separator:a2261502adba46d36318c7756abc16ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdda24e827a6888dd52a0d7a18010a8"><td class="memItemLeft" align="right" valign="top"><a id="a3bdda24e827a6888dd52a0d7a18010a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>valid</b> (void) const</td></tr>
<tr class="separator:a3bdda24e827a6888dd52a0d7a18010a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636d355ffcadf5e605f3cad035f05631"><td class="memItemLeft" align="right" valign="top"><a id="a636d355ffcadf5e605f3cad035f05631"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> (void) const</td></tr>
<tr class="separator:a636d355ffcadf5e605f3cad035f05631"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a8a5f95c981e5e2ed8f5119c037f93290">from_value</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *rt, const T &amp;value)</td></tr>
<tr class="separator:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748cf065d38332f8d0c77053e77439e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a748cf065d38332f8d0c77053e77439e0">from_untyped_pointer</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *rt, const void *buffer, size_t bytes)</td></tr>
<tr class="separator:a748cf065d38332f8d0c77053e77439e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6996c119a390ac94b6ea39cbbc76cff8"><td class="memItemLeft" align="right" valign="top"><a id="a6996c119a390ac94b6ea39cbbc76cff8"></a>
FRIEND_ALL_RUNTIME_CLASSES&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (Internal::FutureImpl *impl)</td></tr>
<tr class="separator:a6996c119a390ac94b6ea39cbbc76cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Futures are the objects returned from asynchronous task launches. Applications can wait on futures to get their values, pass futures as arguments and preconditions to other tasks, or use them to create predicates if they are boolean futures. Futures are lightweight handles that can be passed by value or stored in data structures. However, futures should not escape the context in which they are created as the runtime garbage collects them after the enclosing task context completes execution.</p>
<p>Since futures can be the result of predicated tasks we also provide a mechanism for checking whether the future contains an empty result. An empty future will be returned for all futures which come from tasks which predicates that resolve to false. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a748cf065d38332f8d0c77053e77439e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748cf065d38332f8d0c77053e77439e0">&#9670;&nbsp;</a></span>from_untyped_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Future::from_untyped_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a future from an untyped pointer. No serialization is performed. </p>

</div>
</div>
<a id="a8a5f95c981e5e2ed8f5119c037f93290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5f95c981e5e2ed8f5119c037f93290">&#9670;&nbsp;</a></span>from_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Future::from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow users to generate their own futures. These futures are guaranteed to always have completed and to always have concrete values. </p>

</div>
</div>
<a id="afb7a29669acc4318532869600dd15a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7a29669acc4318532869600dd15a52">&#9670;&nbsp;</a></span>get_reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; Legion::Future::get_reference </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const reference to the future. WARNING: these method is unsafe as the underlying buffer containing the future result can be deleted if the <a class="el" href="class_legion_1_1_future.html">Future</a> handle is lost even a reference to the underlying buffer is maitained. This scenario can lead to seg-faults. Use at your own risk. Note also that this call will not properly deserialize buffers that were serialized with a 'legion_serialize' method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86d6f6ad66bcd8dbccd34205d758c572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d6f6ad66bcd8dbccd34205d758c572">&#9670;&nbsp;</a></span>get_result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Legion::Future::get_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait on the result of this future. Return the value of the future as the specified template type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the future cast as the template type </dd></dl>

</div>
</div>
<a id="a9073b0ea27ef17c90ca1c8c578484b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9073b0ea27ef17c90ca1c8c578484b26">&#9670;&nbsp;</a></span>get_untyped_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* Legion::Future::get_untyped_pointer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an untyped pointer to the future result. WARNING: this method is unsafe for the same reasons as get_reference. It also will not deserialize anything serialized with a legion_serialize method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a334c6926a0611e1f38de5402de58eee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334c6926a0611e1f38de5402de58eee0">&#9670;&nbsp;</a></span>get_untyped_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Legion::Future::get_untyped_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of bytes contained in the future. </p>

</div>
</div>
<a id="af78f1556f5d5ef988aea56f5a2aaba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78f1556f5d5ef988aea56f5a2aaba52">&#9670;&nbsp;</a></span>get_void_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Future::get_void_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block until the future completes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75721ea98fd87fc454f657d5651407e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75721ea98fd87fc454f657d5651407e0">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Future::is_empty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the future is empty. The user can specify whether to block and wait for the future to complete first before returning. If the non-blocking version of the call will return true, until the future actually completes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>indicate whether to block for the result </td></tr>
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>legion/<a class="el" href="legion_8h_source.html">legion.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 29 2017 16:30:12 for Legion Runtime by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
