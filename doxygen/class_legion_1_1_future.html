<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Legion Runtime: Legion::Future Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Legion Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_legion.html">Legion</a></li><li class="navelem"><a class="el" href="class_legion_1_1_future.html">Future</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_legion_1_1_future-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Legion::Future Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="legion_8h_source.html">legion.h</a>&gt;</code></p>

<p>Inherits Legion::Unserializable&lt; T &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10a3d3e23bd7c52825311dc88762236a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a3d3e23bd7c52825311dc88762236a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f)</td></tr>
<tr class="separator:a10a3d3e23bd7c52825311dc88762236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed60935d20925adccd4191c2555a85c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ed60935d20925adccd4191c2555a85c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f) const </td></tr>
<tr class="separator:a0ed60935d20925adccd4191c2555a85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0119229b21262e9467fcb845e2b8f152"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0119229b21262e9467fcb845e2b8f152"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f) const </td></tr>
<tr class="separator:a0119229b21262e9467fcb845e2b8f152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9fdbf419203ec480f2dc4af4280f86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d9fdbf419203ec480f2dc4af4280f86"></a>
<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f)</td></tr>
<tr class="separator:a6d9fdbf419203ec480f2dc4af4280f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab10888555bd9e313e961165f2fda801"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab10888555bd9e313e961165f2fda801"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#aab10888555bd9e313e961165f2fda801">get_result</a> (bool silence_warnings=false) const </td></tr>
<tr class="separator:aab10888555bd9e313e961165f2fda801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abc957baa95e9df0ee424050aa7d17b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a2abc957baa95e9df0ee424050aa7d17b">get_void_result</a> (bool silence_warnings=false) const </td></tr>
<tr class="separator:a2abc957baa95e9df0ee424050aa7d17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a686a2469666cab55ee3f52848952ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a1a686a2469666cab55ee3f52848952ee">is_empty</a> (bool block=false, bool silence_warnings=false) const </td></tr>
<tr class="separator:a1a686a2469666cab55ee3f52848952ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c5ade7de4a6b6f9e606b83cdced5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a7a5c5ade7de4a6b6f9e606b83cdced5c">is_ready</a> (void) const </td></tr>
<tr class="separator:a7a5c5ade7de4a6b6f9e606b83cdced5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7a29669acc4318532869600dd15a52"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb7a29669acc4318532869600dd15a52"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#afb7a29669acc4318532869600dd15a52">get_reference</a> (bool silence_warnings=false)</td></tr>
<tr class="separator:afb7a29669acc4318532869600dd15a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9073b0ea27ef17c90ca1c8c578484b26"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a9073b0ea27ef17c90ca1c8c578484b26">get_untyped_pointer</a> (bool silence_warnings=false)</td></tr>
<tr class="separator:a9073b0ea27ef17c90ca1c8c578484b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334c6926a0611e1f38de5402de58eee0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a334c6926a0611e1f38de5402de58eee0">get_untyped_size</a> (void)</td></tr>
<tr class="separator:a334c6926a0611e1f38de5402de58eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2261502adba46d36318c7756abc16ff1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2261502adba46d36318c7756abc16ff1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2261502adba46d36318c7756abc16ff1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (void)</td></tr>
<tr class="separator:a2261502adba46d36318c7756abc16ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49e8be1aec5c2be2b64952ae5a95d1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa49e8be1aec5c2be2b64952ae5a95d1d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>valid</b> (void) const </td></tr>
<tr class="separator:aa49e8be1aec5c2be2b64952ae5a95d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8be33620668a3248ba5970028bcc530"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8be33620668a3248ba5970028bcc530"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> (void) const </td></tr>
<tr class="separator:af8be33620668a3248ba5970028bcc530"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a8a5f95c981e5e2ed8f5119c037f93290">from_value</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *rt, const T &amp;value)</td></tr>
<tr class="separator:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748cf065d38332f8d0c77053e77439e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a748cf065d38332f8d0c77053e77439e0">from_untyped_pointer</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *rt, const void *buffer, size_t bytes)</td></tr>
<tr class="separator:a748cf065d38332f8d0c77053e77439e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa66588a7cce77ed52dfca26593abcbc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa66588a7cce77ed52dfca26593abcbc1"></a>
FRIEND_ALL_RUNTIME_CLASSES&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (Internal::FutureImpl *impl, bool need_reference=true)</td></tr>
<tr class="separator:aa66588a7cce77ed52dfca26593abcbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Futures are the objects returned from asynchronous task launches. Applications can wait on futures to get their values, pass futures as arguments and preconditions to other tasks, or use them to create predicates if they are boolean futures. Futures are lightweight handles that can be passed by value or stored in data structures. However, futures should not escape the context in which they are created as the runtime garbage collects them after the enclosing task context completes execution.</p>
<p>Since futures can be the result of predicated tasks we also provide a mechanism for checking whether the future contains an empty result. An empty future will be returned for all futures which come from tasks which predicates that resolve to false. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a748cf065d38332f8d0c77053e77439e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Future::from_untyped_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a future from an untyped pointer. No serialization is performed. </p>

</div>
</div>
<a class="anchor" id="a8a5f95c981e5e2ed8f5119c037f93290"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Future::from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow users to generate their own futures. These futures are guaranteed to always have completed and to always have concrete values. </p>

</div>
</div>
<a class="anchor" id="afb7a29669acc4318532869600dd15a52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; Legion::Future::get_reference </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const reference to the future. WARNING: these method is unsafe as the underlying buffer containing the future result can be deleted if the <a class="el" href="class_legion_1_1_future.html">Future</a> handle is lost even a reference to the underlying buffer is maitained. This scenario can lead to seg-faults. Use at your own risk. Note also that this call will not properly deserialize buffers that were serialized with a 'legion_serialize' method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab10888555bd9e313e961165f2fda801"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Legion::Future::get_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait on the result of this future. Return the value of the future as the specified template type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the future cast as the template type </dd></dl>

</div>
</div>
<a class="anchor" id="a9073b0ea27ef17c90ca1c8c578484b26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* Legion::Future::get_untyped_pointer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an untyped pointer to the future result. WARNING: this method is unsafe for the same reasons as get_reference. It also will not deserialize anything serialized with a legion_serialize method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a334c6926a0611e1f38de5402de58eee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Legion::Future::get_untyped_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of bytes contained in the future. </p>

</div>
</div>
<a class="anchor" id="a2abc957baa95e9df0ee424050aa7d17b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Future::get_void_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block until the future completes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a686a2469666cab55ee3f52848952ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Future::is_empty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the future is empty. The user can specify whether to block and wait for the future to complete first before returning. If the non-blocking version of the call will return true, until the future actually completes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>indicate whether to block for the result </td></tr>
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a5c5ade7de4a6b6f9e606b83cdced5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Future::is_ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the future is ready. This will return true if the future can be used without blocking to wait on the computation that the future represents, otherwise it will return false. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="legion_8h_source.html">legion.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 15 2018 16:39:32 for Legion Runtime by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
