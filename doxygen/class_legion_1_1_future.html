<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Legion Runtime: Legion::Future Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Legion Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_legion.html">Legion</a></li><li class="navelem"><a class="el" href="class_legion_1_1_future.html">Future</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_legion_1_1_future-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Legion::Future Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="legion_8h_source.html">legion.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Legion::Future:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_legion_1_1_future.png" usemap="#Legion::Future_map" alt=""/>
  <map id="Legion::Future_map" name="Legion::Future_map">
<area href="class_legion_1_1_unserializable.html" alt="Legion::Unserializable&lt; Future &gt;" shape="rect" coords="0,0,196,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10a3d3e23bd7c52825311dc88762236a" id="r_a10a3d3e23bd7c52825311dc88762236a"><td class="memItemLeft" align="right" valign="top"><a id="a10a3d3e23bd7c52825311dc88762236a" name="a10a3d3e23bd7c52825311dc88762236a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f)</td></tr>
<tr class="separator:a10a3d3e23bd7c52825311dc88762236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302273db7b6b2b53d0c4705a8392077a" id="r_a302273db7b6b2b53d0c4705a8392077a"><td class="memItemLeft" align="right" valign="top"><a id="a302273db7b6b2b53d0c4705a8392077a" name="a302273db7b6b2b53d0c4705a8392077a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&amp;f) noexcept</td></tr>
<tr class="separator:a302273db7b6b2b53d0c4705a8392077a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125f84bf3121946490fc4ad5b8ec8714" id="r_a125f84bf3121946490fc4ad5b8ec8714"><td class="memItemLeft" align="right" valign="top"><a id="a125f84bf3121946490fc4ad5b8ec8714" name="a125f84bf3121946490fc4ad5b8ec8714"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>exists</b> (void) const</td></tr>
<tr class="separator:a125f84bf3121946490fc4ad5b8ec8714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12d5732743bcd588960bae1b85937f4" id="r_ab12d5732743bcd588960bae1b85937f4"><td class="memItemLeft" align="right" valign="top"><a id="ab12d5732743bcd588960bae1b85937f4" name="ab12d5732743bcd588960bae1b85937f4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f) const</td></tr>
<tr class="separator:ab12d5732743bcd588960bae1b85937f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ef3cefe9296e112906ce7683c3f16a" id="r_aa4ef3cefe9296e112906ce7683c3f16a"><td class="memItemLeft" align="right" valign="top"><a id="aa4ef3cefe9296e112906ce7683c3f16a" name="aa4ef3cefe9296e112906ce7683c3f16a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f) const</td></tr>
<tr class="separator:aa4ef3cefe9296e112906ce7683c3f16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d523ddd9c3cc6bde85d49d3a56beccb" id="r_a1d523ddd9c3cc6bde85d49d3a56beccb"><td class="memItemLeft" align="right" valign="top"><a id="a1d523ddd9c3cc6bde85d49d3a56beccb" name="a1d523ddd9c3cc6bde85d49d3a56beccb"></a>
<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_legion_1_1_future.html">Future</a> &amp;f)</td></tr>
<tr class="separator:a1d523ddd9c3cc6bde85d49d3a56beccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac66cf5d88f31f1e0f10788eb5bf914" id="r_a7ac66cf5d88f31f1e0f10788eb5bf914"><td class="memItemLeft" align="right" valign="top"><a id="a7ac66cf5d88f31f1e0f10788eb5bf914" name="a7ac66cf5d88f31f1e0f10788eb5bf914"></a>
<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_legion_1_1_future.html">Future</a> &amp;&amp;f) noexcept</td></tr>
<tr class="separator:a7ac66cf5d88f31f1e0f10788eb5bf914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9b0f90bdf3e2f4a54d7f6786f1f670" id="r_a4c9b0f90bdf3e2f4a54d7f6786f1f670"><td class="memItemLeft" align="right" valign="top"><a id="a4c9b0f90bdf3e2f4a54d7f6786f1f670" name="a4c9b0f90bdf3e2f4a54d7f6786f1f670"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b> (void) const</td></tr>
<tr class="separator:a4c9b0f90bdf3e2f4a54d7f6786f1f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2b520fb8ed45a8a9f004b7c43738f1" id="r_a8f2b520fb8ed45a8a9f004b7c43738f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f2b520fb8ed45a8a9f004b7c43738f1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a8f2b520fb8ed45a8a9f004b7c43738f1">get_result</a> (bool silence_warnings=false, const char *warning_string=NULL) const</td></tr>
<tr class="separator:a8f2b520fb8ed45a8a9f004b7c43738f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f418becdb421423886508ccff1f23f" id="r_a66f418becdb421423886508ccff1f23f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a66f418becdb421423886508ccff1f23f">get_void_result</a> (bool silence_warnings=false, const char *warning_string=NULL) const</td></tr>
<tr class="separator:a66f418becdb421423886508ccff1f23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50246caef8297b5502cc0df9b550a39" id="r_ac50246caef8297b5502cc0df9b550a39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#ac50246caef8297b5502cc0df9b550a39">is_empty</a> (bool block=false, bool silence_warnings=false, const char *warning_string=NULL) const</td></tr>
<tr class="separator:ac50246caef8297b5502cc0df9b550a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c321cf0c5eecf5cd73874aa4f873b9" id="r_ae4c321cf0c5eecf5cd73874aa4f873b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#ae4c321cf0c5eecf5cd73874aa4f873b9">is_ready</a> (bool subscribe=false) const</td></tr>
<tr class="separator:ae4c321cf0c5eecf5cd73874aa4f873b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2beb7f6bfc81ffbfd7dc3f7799610f" id="r_a3b2beb7f6bfc81ffbfd7dc3f7799610f"><td class="memTemplParams" colspan="2">template&lt;typename T , PrivilegeMode PM = LEGION_READ_ONLY&gt; </td></tr>
<tr class="memitem:a3b2beb7f6bfc81ffbfd7dc3f7799610f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_legion_1_1_span.html">Span</a>&lt; T, PM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a3b2beb7f6bfc81ffbfd7dc3f7799610f">get_span</a> (Memory::Kind memory, bool silence_warnings=false, const char *warning_string=NULL) const</td></tr>
<tr class="separator:a3b2beb7f6bfc81ffbfd7dc3f7799610f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15dda14764261ff8626671525d697ab1" id="r_a15dda14764261ff8626671525d697ab1"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a15dda14764261ff8626671525d697ab1">get_buffer</a> (Memory::Kind memory, size_t *extent_in_bytes=NULL, bool check_extent=false, bool silence_warnings=false, const char *warning_string=NULL) const</td></tr>
<tr class="separator:a15dda14764261ff8626671525d697ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb461b73f04b58ae977eda0ce6e741f" id="r_a0eb461b73f04b58ae977eda0ce6e741f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a0eb461b73f04b58ae977eda0ce6e741f">get_memories</a> (std::set&lt; Memory &gt; &amp;memories, bool silence_warnings=false, const char *warning_string=NULL) const</td></tr>
<tr class="separator:a0eb461b73f04b58ae977eda0ce6e741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36fb6367050f498fe2e8e85e85a4ecd" id="r_ab36fb6367050f498fe2e8e85e85a4ecd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab36fb6367050f498fe2e8e85e85a4ecd"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#ab36fb6367050f498fe2e8e85e85a4ecd">get_reference</a> (bool silence_warnings=false, const char *warning_string=NULL) const</td></tr>
<tr class="separator:ab36fb6367050f498fe2e8e85e85a4ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353d23c3b8177841829ebab1af1aa4e2" id="r_a353d23c3b8177841829ebab1af1aa4e2"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a353d23c3b8177841829ebab1af1aa4e2">get_untyped_pointer</a> (bool silence_warnings=false, const char *warning_string=NULL) const</td></tr>
<tr class="separator:a353d23c3b8177841829ebab1af1aa4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a431d0c562f2069a913c4417b910d69" id="r_a5a431d0c562f2069a913c4417b910d69"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a5a431d0c562f2069a913c4417b910d69">get_untyped_size</a> (void) const</td></tr>
<tr class="separator:a5a431d0c562f2069a913c4417b910d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b05b52757b31ae2a12868b5d13a815a" id="r_a5b05b52757b31ae2a12868b5d13a815a"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a5b05b52757b31ae2a12868b5d13a815a">get_metadata</a> (size_t *size=NULL) const</td></tr>
<tr class="separator:a5b05b52757b31ae2a12868b5d13a815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2261502adba46d36318c7756abc16ff1" id="r_a2261502adba46d36318c7756abc16ff1"><td class="memTemplParams" colspan="2"><a id="a2261502adba46d36318c7756abc16ff1" name="a2261502adba46d36318c7756abc16ff1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2261502adba46d36318c7756abc16ff1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (void)</td></tr>
<tr class="separator:a2261502adba46d36318c7756abc16ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdda24e827a6888dd52a0d7a18010a8" id="r_a3bdda24e827a6888dd52a0d7a18010a8"><td class="memItemLeft" align="right" valign="top"><a id="a3bdda24e827a6888dd52a0d7a18010a8" name="a3bdda24e827a6888dd52a0d7a18010a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>valid</b> (void) const</td></tr>
<tr class="separator:a3bdda24e827a6888dd52a0d7a18010a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636d355ffcadf5e605f3cad035f05631" id="r_a636d355ffcadf5e605f3cad035f05631"><td class="memItemLeft" align="right" valign="top"><a id="a636d355ffcadf5e605f3cad035f05631" name="a636d355ffcadf5e605f3cad035f05631"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> (void) const</td></tr>
<tr class="separator:a636d355ffcadf5e605f3cad035f05631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_legion_1_1_unserializable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_legion_1_1_unserializable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_legion_1_1_unserializable.html">Legion::Unserializable&lt; Future &gt;</a></td></tr>
<tr class="memitem:a5130925a9ea7a47cd5d3956fcdb3ce12 inherit pub_methods_class_legion_1_1_unserializable" id="r_a5130925a9ea7a47cd5d3956fcdb3ce12"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>legion_buffer_size</b> (void)</td></tr>
<tr class="separator:a5130925a9ea7a47cd5d3956fcdb3ce12 inherit pub_methods_class_legion_1_1_unserializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242d124cde8565c2b2d2dc35892ef1a6 inherit pub_methods_class_legion_1_1_unserializable" id="r_a242d124cde8565c2b2d2dc35892ef1a6"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>legion_serialize</b> (void *buffer)</td></tr>
<tr class="separator:a242d124cde8565c2b2d2dc35892ef1a6 inherit pub_methods_class_legion_1_1_unserializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b127071f09541607c16fa9e39f0196 inherit pub_methods_class_legion_1_1_unserializable" id="r_ae8b127071f09541607c16fa9e39f0196"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>legion_deserialize</b> (const void *buffer)</td></tr>
<tr class="separator:ae8b127071f09541607c16fa9e39f0196 inherit pub_methods_class_legion_1_1_unserializable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8a5f95c981e5e2ed8f5119c037f93290" id="r_a8a5f95c981e5e2ed8f5119c037f93290"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a8a5f95c981e5e2ed8f5119c037f93290">from_value</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *rt, const T &amp;value)</td></tr>
<tr class="separator:a8a5f95c981e5e2ed8f5119c037f93290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84771deb48169ad4b4907c97296f00d9" id="r_a84771deb48169ad4b4907c97296f00d9"><td class="memTemplParams" colspan="2"><a id="a84771deb48169ad4b4907c97296f00d9" name="a84771deb48169ad4b4907c97296f00d9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84771deb48169ad4b4907c97296f00d9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_value</b> (const T &amp;value)</td></tr>
<tr class="separator:a84771deb48169ad4b4907c97296f00d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5f623595b655c6b20433f746bcff4f" id="r_a1d5f623595b655c6b20433f746bcff4f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_legion_1_1_future.html#a1d5f623595b655c6b20433f746bcff4f">from_untyped_pointer</a> (<a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *rt, const void *buffer, size_t bytes, bool take_ownership=false)</td></tr>
<tr class="separator:a1d5f623595b655c6b20433f746bcff4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4439c236110ad00b15015254311d5cba" id="r_a4439c236110ad00b15015254311d5cba"><td class="memItemLeft" align="right" valign="top"><a id="a4439c236110ad00b15015254311d5cba" name="a4439c236110ad00b15015254311d5cba"></a>
static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><b>from_untyped_pointer</b> (const void *buffer, size_t bytes, bool take_ownership=false, const char *provenance=NULL, bool shard_local=false)</td></tr>
<tr class="separator:a4439c236110ad00b15015254311d5cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a19d8778bab1b75dfa920be8342d606" id="r_a7a19d8778bab1b75dfa920be8342d606"><td class="memItemLeft" align="right" valign="top"><a id="a7a19d8778bab1b75dfa920be8342d606" name="a7a19d8778bab1b75dfa920be8342d606"></a>
static <a class="el" href="class_legion_1_1_future.html">Future</a>&#160;</td><td class="memItemRight" valign="bottom"><b>from_value</b> (const void *buffer, size_t bytes, bool owned, const Realm::ExternalInstanceResource &amp;resource, void(*freefunc)(const Realm::ExternalInstanceResource &amp;)=NULL, const char *provenance=NULL, bool shard_local=false)</td></tr>
<tr class="separator:a7a19d8778bab1b75dfa920be8342d606"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6996c119a390ac94b6ea39cbbc76cff8" id="r_a6996c119a390ac94b6ea39cbbc76cff8"><td class="memItemLeft" align="right" valign="top"><a id="a6996c119a390ac94b6ea39cbbc76cff8" name="a6996c119a390ac94b6ea39cbbc76cff8"></a>
FRIEND_ALL_RUNTIME_CLASSES&#160;</td><td class="memItemRight" valign="bottom"><b>Future</b> (Internal::FutureImpl *impl)</td></tr>
<tr class="separator:a6996c119a390ac94b6ea39cbbc76cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Futures are the objects returned from asynchronous task launches. Applications can wait on futures to get their values, pass futures as arguments and preconditions to other tasks, or use them to create predicates if they are boolean futures. Futures are lightweight handles that can be passed by value or stored in data structures. However, futures should not escape the context in which they are created as the runtime garbage collects them after the enclosing task context completes execution.</p>
<p>Since futures can be the result of predicated tasks we also provide a mechanism for checking whether the future contains an empty result. An empty future will be returned for all futures which come from tasks which predicates that resolve to false. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1d5f623595b655c6b20433f746bcff4f" name="a1d5f623595b655c6b20433f746bcff4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5f623595b655c6b20433f746bcff4f">&#9670;&#160;</a></span>from_untyped_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Future::from_untyped_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_ownership</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a future from an untyped pointer. No serialization is performed. </p>

</div>
</div>
<a id="a8a5f95c981e5e2ed8f5119c037f93290" name="a8a5f95c981e5e2ed8f5119c037f93290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5f95c981e5e2ed8f5119c037f93290">&#9670;&#160;</a></span>from_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_legion_1_1_future.html">Future</a> Legion::Future::from_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_legion_1_1_runtime.html">Runtime</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow users to generate their own futures. These futures are guaranteed to always have completed and to always have concrete values. </p>

</div>
</div>
<a id="a15dda14764261ff8626671525d697ab1" name="a15dda14764261ff8626671525d697ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15dda14764261ff8626671525d697ab1">&#9670;&#160;</a></span>get_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * Legion::Future::get_buffer </td>
          <td>(</td>
          <td class="paramtype">Memory::Kind&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>extent_in_bytes</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_extent</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer and optional size for the data for the future. The pointer is only valid as long as the application program maintains a handle to the future object that produced it. This call will not deserialized data packed with the legion_serialize method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>the kind of memory for the allocation, the memory with the best affinity to the executing processor will be used </td></tr>
    <tr><td class="paramname">extent_in_bytes</td><td>pointer to a location to write the future size </td></tr>
    <tr><td class="paramname">check_extent</td><td>check that the extent matches the future size </td></tr>
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with any warnings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the future data in the specified memory </dd></dl>

</div>
</div>
<a id="a0eb461b73f04b58ae977eda0ce6e741f" name="a0eb461b73f04b58ae977eda0ce6e741f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb461b73f04b58ae977eda0ce6e741f">&#9670;&#160;</a></span>get_memories()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Future::get_memories </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; Memory &gt; &amp;&#160;</td>
          <td class="paramname"><em>memories</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Report an instantaneous set of available memories where instances for the this future exist. These will only be memories local to the current process in which the call is performed. The result of this query might be come stale as soon as it is returned since it is only a snapshot of the memories where the future has copies. </p>

</div>
</div>
<a id="a5b05b52757b31ae2a12868b5d13a815a" name="a5b05b52757b31ae2a12868b5d13a815a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b05b52757b31ae2a12868b5d13a815a">&#9670;&#160;</a></span>get_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * Legion::Future::get_metadata </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em> = <code>NULL</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the metadata buffer for this future. Unlike getting a buffer for the future which can exist on any memory, the metadata is always guaranteed to be on the host memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optional</td><td>pointer to a place to write the size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the buffer containing the metadata </dd></dl>

</div>
</div>
<a id="ab36fb6367050f498fe2e8e85e85a4ecd" name="ab36fb6367050f498fe2e8e85e85a4ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36fb6367050f498fe2e8e85e85a4ecd">&#9670;&#160;</a></span>get_reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; Legion::Future::get_reference </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a const reference to the future. WARNING: these method is unsafe as the underlying buffer containing the future result can be deleted if the <a class="el" href="class_legion_1_1_future.html">Future</a> handle is lost even a reference to the underlying buffer is maitained. This scenario can lead to seg-faults. Use at your own risk. Note also that this call will not properly deserialize buffers that were serialized with a 'legion_serialize' method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f2b520fb8ed45a8a9f004b7c43738f1" name="a8f2b520fb8ed45a8a9f004b7c43738f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2b520fb8ed45a8a9f004b7c43738f1">&#9670;&#160;</a></span>get_result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Legion::Future::get_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait on the result of this future. Return the value of the future as the specified template type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the future cast as the template type </dd></dl>

</div>
</div>
<a id="a3b2beb7f6bfc81ffbfd7dc3f7799610f" name="a3b2beb7f6bfc81ffbfd7dc3f7799610f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2beb7f6bfc81ffbfd7dc3f7799610f">&#9670;&#160;</a></span>get_span()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PrivilegeMode PM = LEGION_READ_ONLY&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_legion_1_1_span.html">Span</a>&lt; T, PM &gt; Legion::Future::get_span </td>
          <td>(</td>
          <td class="paramtype">Memory::Kind&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a span object representing the data for the future. The size of the future must be evenly divisible by sizeof(T). The resulting span object is only good as long as the application program maintains a handle to the future object that created it. At the moment the privilege mode must be read-only; no other values will be accepted. This call will not unpack data serialized with the legion_serialize method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>the kind of memory for the allocation, the memory with the best affinity to the executing processor will be used </td></tr>
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with any warnings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_legion_1_1_span.html">Span</a> object representing the data for the future </dd></dl>

</div>
</div>
<a id="a353d23c3b8177841829ebab1af1aa4e2" name="a353d23c3b8177841829ebab1af1aa4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353d23c3b8177841829ebab1af1aa4e2">&#9670;&#160;</a></span>get_untyped_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * Legion::Future::get_untyped_pointer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an untyped pointer to the future result. WARNING: this method is unsafe for the same reasons as get_reference. It also will not deserialize anything serialized with a legion_serialize method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a431d0c562f2069a913c4417b910d69" name="a5a431d0c562f2069a913c4417b910d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a431d0c562f2069a913c4417b910d69">&#9670;&#160;</a></span>get_untyped_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Legion::Future::get_untyped_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of bytes contained in the future. </p>

</div>
</div>
<a id="a66f418becdb421423886508ccff1f23f" name="a66f418becdb421423886508ccff1f23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f418becdb421423886508ccff1f23f">&#9670;&#160;</a></span>get_void_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Legion::Future::get_void_result </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Block until the future completes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac50246caef8297b5502cc0df9b550a39" name="ac50246caef8297b5502cc0df9b550a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac50246caef8297b5502cc0df9b550a39">&#9670;&#160;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Future::is_empty </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>silence_warnings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>warning_string</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the future is empty. The user can specify whether to block and wait for the future to complete first before returning. If the non-blocking version of the call will return true, until the future actually completes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>indicate whether to block for the result </td></tr>
    <tr><td class="paramname">silence_warnings</td><td>silence any warnings for this blocking call </td></tr>
    <tr><td class="paramname">warning_string</td><td>a string to be reported with the warning </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4c321cf0c5eecf5cd73874aa4f873b9" name="ae4c321cf0c5eecf5cd73874aa4f873b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c321cf0c5eecf5cd73874aa4f873b9">&#9670;&#160;</a></span>is_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Legion::Future::is_ready </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subscribe</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if the future is ready. This will return true if the future can be used without blocking to wait on the computation that the future represents, otherwise it will return false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subscribe</td><td>ask for the payload to be brought here when ready </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="legion_8h_source.html">legion.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 5 2025 18:09:59 for Legion Runtime by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
