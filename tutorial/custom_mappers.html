<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Custom Mappers &#8211; Legion Programming System</title>
<meta name="description" content="">

<meta name="keywords" content="">


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Custom Mappers">
<meta property="og:description" content="Home page for the Legion parallel programming system">
<meta property="og:url" content="/tutorial/custom_mappers.html">
<meta property="og:site_name" content="Legion Programming System">





<link rel="canonical" href="/tutorial/custom_mappers.html">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Legion Programming System Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.min.css">

<!--[if (lt IE 9) & (!IEMobile)]>
<link rel="stylesheet" href="/assets/css/ie.min.css">
<![endif]-->

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="page" itemscope itemtype="http://schema.org/WebPage">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="/">Legion Programming System</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
		    <ul>
		        
				<li><a href="/overview/" >Overview</a></li>
		        
				<li><a href="/starting/" >Getting Started</a></li>
		        
				<li><a href="/tutorial/" >Tutorials</a></li>
		        
				<li><a href="/bootcamp/" >Bootcamp</a></li>
		        
				<li><a href="/documentation/" >Documentation</a></li>
		        
				<li><a href="/publications/" >Publications</a></li>
		        
				<li><a href="/resources/" >Resources</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main"  itemprop="mainContentOfPage">
  <div class="article-author-side">
    <img src="/images/legion_logo.jpg" class="bio-photo" alt="Legion bio photo"></a>
<h3>Legion</h3>
<p>A Data-Centric Parallel Programming System</p>





<a href="http://github.com/StanfordLegion/legion" class="author-social" target="_blank"><i class="icon-github"></i> Github</a>


  </div>
  <article itemscope itemtype="http://schema.org/CreativeWork">
    <h1 itemprop="name">Custom Mappers</h1>
    <div class="article-wrap" itemprop="text">
      <p>One of the primary goals of Legion is to
make it easy to remap applications onto
different architectures. Up to this point
all of our applications have been mapped
by the <code class="highlighter-rouge">DefaultMapper</code> implementation that
is distributed with Legion. The <code class="highlighter-rouge">DefaultMapper</code>
class provides heuristics for performing mappings
that are good, but regularly not optimal for
specific applications or architectures. By
creating custom mappers programmers can make
application- or architecture-specific mapping
decisions. Furthermore, the mapping interface
isolates mapping decisions from application
code, allowing the same Legion applications
to be targeted at different architectures without
having to modify the application source code.</p>

<p>A common problem encountered when writing code 
for large distributed and heterogeneous machines 
is how mapping impacts correctness. In Legion all
mapping decisions are orthogonal to correctness.
Legion will always perform the necessary operations
to ensure that data is accessed safely with regards
to the specific privilege and coherence constraints
specified in the application. In cases where
mappers generate invalid responses to mapping
queries (e.g. a mapper maps a physical region for
a task into a memory not visible from the target
processor), then the Legion runtime will notify the
mapper that it tried to perform an illegal mapping
and allow it to retry.</p>

<p>To introduce how to write a custom mapper we’ll
implement two custom mappers. The first will be
an adversarial mapper that makes random mapping 
decisions designed to stress-test the Legion runtime.
We’ll also have the adversarial mapper report the chosen
mapping decisions (which will change with each run
of the application) to further emphasize the orthogonality
of mapping decisions from correctness. The second mapper
that we’ll create will be used for partitioning to decide
how many sub-regions to create using <em>tunable</em> 
variables. The application code for DAXPY is nearly 
identical to the code from 
an <a href="/tutorial/partitioning.html">earlier example</a>
and is therefore omitted. We only show the new
code required for creating and implementing the
custom mappers.</p>

<h4 id="mapper-objects-and-registration">Mapper Objects and Registration</h4>

<p>Mappers are classes that implement the mapping interface
declared in the abstract <code class="highlighter-rouge">Mapper</code> objection in the
legion.h header file. Legion provides a default
implementation of this interface defined by the 
<code class="highlighter-rouge">DefaultMapper</code> class (from the default_mapper.h
header file on line 2). The default mapper allows
applications to be developed without being
concerned with mapping decisions. Once correctness
has been established, programmers can implement
custom mappers to achieve higher performance. 
Custom mappers can either extend the <code class="highlighter-rouge">DefaultMapper</code>
class or implement the <code class="highlighter-rouge">Mapper</code> interface from
scratch. In this example, we extend the 
<code class="highlighter-rouge">DefaultMapper</code> to create both our <code class="highlighter-rouge">AdversarialMapper</code>
(line 13) and <code class="highlighter-rouge">PartitioningMapper</code> (line 25). We then override 
four of the mapping interface calls in the <code class="highlighter-rouge">AdversarialMapper</code>
(lines 18-22) and one in the <code class="highlighter-rouge">PartitioningMapper</code> (lines 30-32)
to show how they work. We’ll detail the semantics and our implementation
of them in the coming sections.</p>

<p>Mappers objects are instantiated after the
Legion runtime starts but before the application
begins executing. To instantiate mappers, the application
registers a callback function for the runtime to
invoke prior to beginning execution of the application. In this
example we create the <code class="highlighter-rouge">mapper_registration</code>
function (lines 35-45) and register the function
with runtime using the static method <code class="highlighter-rouge">set_registration_callback</code>
on the <code class="highlighter-rouge">HighLevelRuntime</code> (line 279). All callback
functions must have the same type as the <code class="highlighter-rouge">mapper_registration</code>
function which allows the runtime to pass the 
necessary parameters for creating new mappers.</p>

<p>The model for Legion is that a specific kind of
mapper is identified by a <code class="highlighter-rouge">MapperID</code> (unsigned integer)
and there should be a single instance of each kind of mapper
for every processor in the system. Having a single
instance for each processor guarantees that processors
can map tasks in parallel without needing to be
concerned about contention for a single mapper object.
For mappers that are stateful, this can sometimes
lead to mapper instances having incomplete information,
but this would occur naturally in a distributed system
anyway as there would at least have to be different
mapper instances for processes on different nodes.
In practice, we find that having one mapper of each
kind for every processor is a straight-forward model.</p>

<p>When the callback function is invoked, it can
instantiate an arbitrary number of kinds of mappers.
For each kind, it should create one instance for
every processor in the set <code class="highlighter-rouge">local_procs</code> which
describes the set of processors on the local node
(the callback is invoked in parallel by the
instance of the Legion runtime in every process
with the correct set of processors local to the process).
Zero is reserved as a special <code class="highlighter-rouge">MapperID</code> for
the <code class="highlighter-rouge">DefaultMapper</code>, but applications can replace
the default mapper using the <code class="highlighter-rouge">replace_default_mapper</code>
method on the <code class="highlighter-rouge">HighLevelRuntime</code> (lines 40-41).
By replacing the default mapper, our tasks will
automatically use the new <code class="highlighter-rouge">AdversarialMapper</code>
to handle mapping queries. We register the 
instances of the <code class="highlighter-rouge">PartitioningMapper</code> with 
the <code class="highlighter-rouge">add_mapper</code> method and pass
<code class="highlighter-rouge">PARTITIONING_MAPPER_ID</code> as the <code class="highlighter-rouge">MapperID</code>
which is set to be <code class="highlighter-rouge">1</code>. We’ll show how to use
mapper IDs to determine which mapper is invoked
momentarily. Finally, notice that we iterate over
all the processors in the set of <code class="highlighter-rouge">local_procs</code>
to create a separate instance of both the <code class="highlighter-rouge">AdversarialMapper</code>
and the <code class="highlighter-rouge">PartitioningMapper</code> for each processor (lines 40-43).</p>

<h4 id="legion-machine-model">Legion Machine Model</h4>

<p>In order to target a specific architecture, mappers need
access to a description of the underlying hardware.
Legion provides a static singleton <code class="highlighter-rouge">Machine</code> object
that can be used to make queries concerning the
underlying hardware. We show how to make some of these
queries as part of the constructor for our <code class="highlighter-rouge">AdversarialMapper</code>
object (lines 47-173).</p>

<p>A pointer to the <code class="highlighter-rouge">Machine</code> singleton is passed as part
of the arguments to any mapper constructor, but it
can also always be obtained by calling the static method
<code class="highlighter-rouge">get_machine</code> of the <code class="highlighter-rouge">Machine</code> type from anywhere in the
application. The <code class="highlighter-rouge">Machine</code> type
actually comes from the Legion low-level runtime, but
typedefs are used to ensure the proper types are all
available for application use as well. In our constructor
we begin by obtaining a reference to the STL set of
all the processors in the machine (line 51). The
<code class="highlighter-rouge">Processor</code> objects are simply light-weight handles
for naming all of the processors in the machine. The
set of all processors can depend on which version of
the low-level runtime as well as command line arguments
such as the <code class="highlighter-rouge">-ll:cpu &lt;#&gt;</code> flag which specifies the
number of CPU processors to create. (It is on our
TODO list to have the low-level runtime inspect the 
hardware to automatically discover the underlying
machine architecture. More details on how to 
configure the Legion low-level runtime can be 
found <a href="/profiling/index.html#machine">here</a>.)</p>

<p>We now want to print out information about the
underlying processors and memories for our machine.
To do this we first add the conditional on line 31
to ensure that only one mapper performs the output.
Recall a separate instance of the <code class="highlighter-rouge">AdversarialMapper</code>
will be made for every processor. We only have the 
mapper whose local processor is the first one in
the set of all processors do the printing. We then
iterate over the set of all processors and print out
their ID and type (lines 54-83). Most objects
obtained from the <code class="highlighter-rouge">Machine</code> object have an associated
<code class="highlighter-rouge">id</code> field that can uniquely identify them (it is
useful to print these IDs in hexadecimal format).
There are currently three types of processors supported
by the Legion runtime: latency-optimized processors
(<code class="highlighter-rouge">LOC_PROC</code>) are CPU processors, throughput-optimized
processors (<code class="highlighter-rouge">TOC_PROC</code>) are GPUs, and utility processors
are special CPU processors used for performing Legion
runtime tasks. (Utility processors can also be used
for running Legion tasks, but may suffer from longer
latencies as they will be interleaved with runtime-level
operations.)</p>

<p>We also obtain and print the list of
memories as well as their kinds and sizes (lines 84-158).
Note memory sizes are controlled by command line
values and may not accurately reflect the actual
underlying hardware (e.g. the L1-cache values in
our shared-memory-only low-level runtime). Different
architectures should use different command line
arguments to properly set these values until
Legion learns to discover the underlying hardware.
More information on configuring the Legion low-level
runtime parameters with command line flags can
be found <a href="/profiling/index.html#machine">here</a>.</p>

<p>A useful way to think about the Legion machine
model encapsulated by the <code class="highlighter-rouge">Machine</code> objects is as a
graph with processors and memories as two kinds
of nodes. There are two kinds of edges in this graph:
processor-memory edges and memory-memory edges. An
edge between a processor and a memory indicates that
the processor can directly perform load and store
operations to that memory. Memory-memory edges indicate
that data movement can be directly performed between
the two memories (either by a processor or by a
DMA engine). 
<!-- 
Below is an example graph for the
shared-memory-only low-level runtime with four
processors (default values). We model separate
L1 caches to give the illusion of blocking for
per-processor caches, but still allow all processors
to access any memory because of cache coherence.
 -->
Edges between nodes are called affinities in the
machine model. Affinities are currently dimensionless
and are approximate indications of the latency
and bandwidth between two nodes (again, having the
low-level runtime automatically discover the
actual values is a long-term goal). Line 160 uses
the <code class="highlighter-rouge">get_visible_memories</code> method to obtain the
set of memories visible from the local processor.
We then print out the affinities between the local
processor and each of these memories using the
<code class="highlighter-rouge">get_proc_mem_affinity</code> method (line 167).</p>

<h4 id="assigning-tasks-to-processors">Assigning Tasks to Processors</h4>

<p>The first mapper call that we override is the 
<code class="highlighter-rouge">select_task_options</code> call (lines 175-284). This
mapper call is performed on every task launch
immediately after it is made. The call asks the
mapper to specify some of the important properties
for the task by setting fields on the <code class="highlighter-rouge">Task</code>
object. (Most mapper queries are answered by 
mutating the mapping fields of the <code class="highlighter-rouge">Task</code> object.)</p>

<ul>
  <li><strong>inline_task</strong>: whether the task should be
inlined directly into the parent task’s context
by using the parent task’s physical regions.</li>
  <li><strong>spawn_task</strong>: whether the task is eligible
for stealing (based on Cilk-style semantics).</li>
  <li><strong>map_locally</strong>: whether the task should be
mapped by the processor on which it was launched 
or whether it should be mapped by the processor
where it will run.</li>
  <li><strong>profile_task</strong>: should the runtime collect
profiling information about the task while
it is executing to provide feedback to the 
mapper.</li>
  <li><strong>target_proc</strong>: which processor should the task
be sent to once all of its mapping dependences
have been satisfied and it is ready to map.</li>
</ul>

<p>For our adversarial mapper, we perform the default
choice for all options except the last one. When
we set the <code class="highlighter-rouge">target_proc</code> field we select a random
processor to which the task will be sent. This
is done using a static utility method from <code class="highlighter-rouge">DefaultMapper</code>
which will pick a random processor from a given
STL set (lines 182-183).</p>

<h4 id="slicing-index-task-spaces">Slicing Index Task Spaces</h4>

<p>The second call that we override is the <code class="highlighter-rouge">slice_domain</code>
method (lines 186-205). The <code class="highlighter-rouge">slice_domain</code> method is
used by the runtime to query the mapper about the 
best way to distribute the point tasks from an index
space task launch through the machine. The mapper is
given the domain to slice and then asked to generate
sub-domains to be sent to different processors in the
form of <code class="highlighter-rouge">DomainSplit</code> objects which we also refer
to as <em>slices</em>. <code class="highlighter-rouge">DomainSplit</code> objects describe the 
sub-domain, the target processor, whether the slice
can be stolen, and finally whether <code class="highlighter-rouge">slice_domain</code> should
be recursively invoked on the slice when it arrives
at its destination. Using this call mappers can choose
both the granularity at which index space tasks are
handled and distributed. Furthermore, it also gives
the mapper the ability to hierarchically decompose
an index space by recursively calling <code class="highlighter-rouge">slice_domain</code>
when distributing domains across very large machines.</p>

<p>For our <code class="highlighter-rouge">AdversarialMapper</code> implementation we again use 
another utility method from 
the <code class="highlighter-rouge">DefaultMapper</code> called <code class="highlighter-rouge">decompose_index_space</code>
to decompose our domain into two slices and send the
two slices to two random processors. We continue
recursively dividing domains in half until there
is only one point in each domain. Lines 188-183 choose
the two random processors and lines 195-196 perform
the slicing. We then check to see how many points
are left in each slice and mark that <code class="highlighter-rouge">domain_split</code>
should recursively be called unless there is only
one point left (line 197-204). Overall, this creates a
tree of slices of depth log(N) in the number of
points in the domain with each slice in the tree being
sent to a random processor.</p>

<h4 id="selecting-memories-for-physical-instances">Selecting Memories for Physical Instances</h4>

<p>The next mapping call that we override is the <code class="highlighter-rouge">map_task</code>
method (lines 207-229). Once a task has been assigned
to map on a specific processor (the <code class="highlighter-rouge">target_proc</code> field
in the <code class="highlighter-rouge">Task</code> object), then this method is called by
the runtime to select the memories in which to create
the physical instances of the logical regions requested
by the task’s <code class="highlighter-rouge">RegionRequirement</code> objects. The mapper
specifies the target memories by modifying the mapping
fields on the <code class="highlighter-rouge">RegionRequirement</code> objects (lines 219,
222-225). The memories containing currently valid physical
instances for each <code class="highlighter-rouge">RegionRequirement</code> are provided
by the runtime to the mapper in the <code class="highlighter-rouge">current_instances</code>
field. The mapper specifies an ordered list of memories
for the runtime to try when searching for either an 
existing physical instance or creating a new instance
in the <code class="highlighter-rouge">target_ranking</code> field of each <code class="highlighter-rouge">RegionRequirement</code>.
If the runtime fails to find or make a physical instance
in any of the memories, then the mapping fails and
the mapper will be notified that the task failed to map
using the <code class="highlighter-rouge">notify_mapping_failed</code> mapper call. If the
mapper does nothing in the <code class="highlighter-rouge">notify_mapping_failed</code> call
then the task is placed back on the list of tasks eligible
to be selected for mapping by the <code class="highlighter-rouge">select_tasks_to_schedule</code>
mapper call. In addition to the <code class="highlighter-rouge">target_ranking</code> field
there are other fields which the mapper can set which
we do not cover here (lines 222-225).</p>

<p>For our <code class="highlighter-rouge">AdversarialMapper</code> implementation, the mapper
finds the set of all memories visible from the target
processor and then puts them in a random order as the
target ranking for the runtime to use, thereby challenging
the Legion runtime to maintain correctness of data
that will need to be moved through random sets of memories
as each task runs. Note finally that we return true
as the result of the <code class="highlighter-rouge">map_task</code> method. This instructs
the runtime to call the <code class="highlighter-rouge">notify_mapping_result</code>
method if the mapping of the task succeeds.</p>

<h4 id="reporting-results">Reporting Results</h4>

<p>The last mapper call that we override for our
<code class="highlighter-rouge">AdversarialMapper</code> is the 
<code class="highlighter-rouge">notify_mapping_result</code> method (lines 231-242).
We use this method to report the chosen mapping
for each task, but it is also useful for memoizing
mapping results and for knowing the result of mapping
decisions when profiling tasks. Before invoking
this method, the runtime sets the <code class="highlighter-rouge">selected_memory</code>
field on each <code class="highlighter-rouge">RegionRequirement</code> object in the
vector for each <code class="highlighter-rouge">Task</code>. The mapper can then see
in which memory a physical instance for each 
<code class="highlighter-rouge">RegionRequirement</code> resides. For our <code class="highlighter-rouge">AdversarialMapper</code>
implementation we print the mapping for each logical
region of every task to show that the assignment
of regions to memories is truly random. Every run
of the application should report a different
mapping, but will always report that the correct
answer is computed illustrating the Legion mapping
decisions are orthogonal to correctness.</p>

<h4 id="handling-tunable-variables">Handling Tunable Variables</h4>

<p>When writing tasks, there are often many cases where
variables depend on the underlying nature of the 
machine. In Legion we refer to these variables as
<em>tunable variables</em> because they often need
to be specifically tuned to different architectures.
Since these variables are machine dependent and likely
to affect performance, we prefer to make these variables
explicit. To do this we provide a separate mapping call
<code class="highlighter-rouge">get_tunable_value</code> to explicitly request that the
mapper pick the value for this variable. We override
this call in our <code class="highlighter-rouge">PartitioningMapper</code> on lines 30-32.</p>

<p>We make a slight modification to our DAXPY code to
make the number of sub-regions to create a tunable 
variable so that the mapper can pick a value based 
on the number of processors on the target machine. Note that the
<code class="highlighter-rouge">top_level_task</code> explicitly invokes the <code class="highlighter-rouge">get_tunable_value</code>
to find the number of sub-regions to create (see
the code sample below). When this call is made, we
pass the <code class="highlighter-rouge">PARTITIONING_MAPPER_ID</code> as the value to the
<code class="highlighter-rouge">MapperID</code> field, indicating that an instance of
our <code class="highlighter-rouge">PartitioningMapper</code> should be used to handle 
the request and not an instance of the <code class="highlighter-rouge">AdversarialMapper</code>.
When we make the call we also pass in a <code class="highlighter-rouge">TunableID</code>
which is used to identify the name of the tunable
variable that should be set. This value can by
static or dynamic, so long as the mapper that it
is being sent to knows how to determine it. In
this case we pass <code class="highlighter-rouge">SUBREGION_TUNABLE</code> as the
integer name for tunable variable. On lines
251-264 we can see the implementation of the
<code class="highlighter-rouge">get_tunable_value</code> method for the <code class="highlighter-rouge">PartitioningMapper</code>.
We see that this mapper class knows how handle
queries for values of the <code class="highlighter-rouge">SUBREGION_TUNABLE</code>
tunable variable only. The <code class="highlighter-rouge">PartitioningMapper</code>
instance looks up the total number of processors
in the machine and specifies that as the number
of sub-regions to create.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">num_subregions</span> <span class="o">=</span> 
        <span class="n">runtime</span><span class="o">-&gt;</span><span class="n">get_tunable_value</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">SUBREGION_TUNABLE</span><span class="p">,</span> 
                                   <span class="n">PARTITIONING_MAPPER_ID</span><span class="p">);</span></code></pre></figure>

<p>For the moment tunable variables must be unsigned
integers, but this is primarily a side effect of
C++ not supporting templated virtual methods.
If users have compelling examples of code that
needs other types of tunable variables then 
please let us know.</p>

<h4 id="what-next">What Next?</h4>

<p>Congratulations! You’ve reached the end of the
Legion tutorial as it currently exists. There
are many features already implemented in Legion 
which are not covered by this tutorial including:</p>

<ul>
  <li>reduction operations, reduction privileges,
and reduction instances</li>
  <li>high performance region accessors</li>
  <li>runtime debugging modes and flags</li>
  <li>runtime performance tuning knobs</li>
  <li>unmapping and remapping optimizations</li>
  <li>explicit cross-region copy operations</li>
  <li>additional mapping calls and settings</li>
  <li>close operations and composite instances (pending)</li>
  <li>mapper profiling tools</li>
  <li>relaxed coherence modes</li>
  <li>acquire and release operations for simultaneous coherence</li>
  <li>reservations and phase barriers for synchronization
in a deferred execution model</li>
  <li>predicated operations</li>
  <li>support for speculative execution (in progress)</li>
  <li>inner and idempotent tasks</li>
  <li>efficient data-centric resiliency and recovery (in progress)</li>
</ul>

<p>If you are interested in learning more about how to
use these features of Legion or you have questions
regarding how to use them, please post to the
<a href="http://legion.stanford.edu/forum">discussion board</a>.
<br /><br />
Previous Example: <a href="/tutorial/multiple.html">Multiple Partitions</a></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
</pre></td><td class="code"><pre><span class="cp">#include "legion.h"
#include "default_mapper.h"
</span>
<span class="k">enum</span> <span class="p">{</span>
  <span class="n">SUBREGION_TUNABLE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
  <span class="n">PARTITIONING_MAPPER_ID</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">AdversarialMapper</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultMapper</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">AdversarialMapper</span><span class="p">(</span><span class="n">Machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> 
      <span class="n">HighLevelRuntime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">local</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">select_task_options</span><span class="p">(</span><span class="n">Task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">slice_domain</span><span class="p">(</span><span class="k">const</span> <span class="n">Task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="n">Domain</span> <span class="o">&amp;</span><span class="n">domain</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DomainSplit</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">slices</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">map_task</span><span class="p">(</span><span class="n">Task</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span> 
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">notify_mapping_result</span><span class="p">(</span><span class="k">const</span> <span class="n">Mappable</span> <span class="o">*</span><span class="n">mappable</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PartitioningMapper</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultMapper</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">PartitioningMapper</span><span class="p">(</span><span class="n">Machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span>
      <span class="n">HighLevelRuntime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">local</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">int</span> <span class="n">get_tunable_value</span><span class="p">(</span><span class="k">const</span> <span class="n">Task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
                                <span class="n">TunableID</span> <span class="n">tid</span><span class="p">,</span>
                                <span class="n">MappingTagID</span> <span class="n">tag</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">mapper_registration</span><span class="p">(</span><span class="n">Machine</span> <span class="o">*</span><span class="n">machine</span><span class="p">,</span> <span class="n">HighLevelRuntime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">local_procs</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">local_procs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">local_procs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">rt</span><span class="o">-&gt;</span><span class="n">replace_default_mapper</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">AdversarialMapper</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">),</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
    <span class="n">rt</span><span class="o">-&gt;</span><span class="n">add_mapper</span><span class="p">(</span><span class="n">PARTITIONING_MAPPER_ID</span><span class="p">,</span>
        <span class="k">new</span> <span class="n">PartitioningMapper</span><span class="p">(</span><span class="n">machine</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">),</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">AdversarialMapper</span><span class="p">(</span><span class="n">Machine</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span> 
                                     <span class="n">HighLevelRuntime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span> <span class="n">Processor</span> <span class="n">p</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">DefaultMapper</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="c1">// pass arguments through to DefaultMapper
</span><span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">all_procs</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_all_processors</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="n">all_procs</span><span class="p">.</span><span class="n">begin</span><span class="p">()))</span> <span class="o">==</span> <span class="n">local_proc</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"There are %ld processors:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">all_procs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">all_procs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">all_procs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="c1">// For every processor there is an associated kind
</span>      <span class="n">Processor</span><span class="o">::</span><span class="n">Kind</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_processor_kind</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Latency-optimized cores (LOCs) are CPUs
</span>        <span class="k">case</span> <span class="n">Processor</span><span class="p">:</span><span class="o">:</span><span class="n">LOC_PROC</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Processor ID %x is CPU</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span> 
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Throughput-optimized cores (TOCs) are GPUs
</span>        <span class="k">case</span> <span class="n">Processor</span><span class="p">:</span><span class="o">:</span><span class="n">TOC_PROC</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Processor ID %x is GPU</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Utility processors are helper processors for
</span>        <span class="c1">// running Legion runtime meta-level tasks and 
</span>        <span class="c1">// should not be used for running application tasks
</span>        <span class="k">case</span> <span class="n">Processor</span><span class="p">:</span><span class="o">:</span><span class="n">UTIL_PROC</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Processor ID %x is utility</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="k">default</span><span class="o">:</span>
          <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">all_mems</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_all_memories</span><span class="p">();</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"There are %ld memories:</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">all_mems</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">all_mems</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">all_mems</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Memory</span><span class="o">::</span><span class="n">Kind</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_memory_kind</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
      <span class="kt">size_t</span> <span class="n">memory_size_in_kb</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_memory_size</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">;</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// RDMA addressable memory when running with GASNet
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">GLOBAL_MEM</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  GASNet Global Memory ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> 
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// DRAM on a single node
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">SYSTEM_MEM</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  System Memory ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Pinned memory on a single node
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">REGDMA_MEM</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Pinned Memory ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// A memory associated with a single socket
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">SOCKET_MEM</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Socket Memory ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Zero-copy memory betweeen CPU DRAM and
</span>        <span class="c1">// all GPUs on a single node
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">Z_COPY_MEM</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Zero-Copy Memory ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// GPU framebuffer memory for a single GPU
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">GPU_FB_MEM</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  GPU Frame Buffer Memory ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Block of memory sized for L3 cache
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">LEVEL3_CACHE</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Level 3 Cache ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Block of memory sized for L2 cache
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">LEVEL2_CACHE</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Level 2 Cache ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="c1">// Block of memory sized for L1 cache
</span>        <span class="k">case</span> <span class="n">Memory</span><span class="p">:</span><span class="o">:</span><span class="n">LEVEL1_CACHE</span><span class="o">:</span>
          <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"  Level 1 Cache ID %x has %ld KB</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">memory_size_in_kb</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="k">default</span><span class="o">:</span>
          <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span> <span class="n">vis_mems</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_visible_memories</span><span class="p">(</span><span class="n">local_proc</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"There are %ld memories visible from processor %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">vis_mems</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">local_proc</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">vis_mems</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
          <span class="n">it</span> <span class="o">!=</span> <span class="n">vis_mems</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ProcessorMemoryAffinity</span><span class="o">&gt;</span> <span class="n">affinities</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">results</span> <span class="o">=</span> 
        <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_proc_mem_affinity</span><span class="p">(</span><span class="n">affinities</span><span class="p">,</span> <span class="n">local_proc</span><span class="p">,</span> <span class="o">*</span><span class="n">it</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">results</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"  Memory %x has bandwidth %d and latency %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
              <span class="n">it</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">affinities</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">affinities</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">latency</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">select_task_options</span><span class="p">(</span><span class="n">Task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">task</span><span class="o">-&gt;</span><span class="n">inline_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">task</span><span class="o">-&gt;</span><span class="n">spawn_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">task</span><span class="o">-&gt;</span><span class="n">map_locally</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">task</span><span class="o">-&gt;</span><span class="n">profile_task</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">task</span><span class="o">-&gt;</span><span class="n">task_priority</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">all_procs</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_all_processors</span><span class="p">();</span>
  <span class="n">task</span><span class="o">-&gt;</span><span class="n">target_proc</span> <span class="o">=</span> 
    <span class="n">DefaultMapper</span><span class="o">::</span><span class="n">select_random_processor</span><span class="p">(</span><span class="n">all_procs</span><span class="p">,</span> <span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">,</span> <span class="n">machine</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">slice_domain</span><span class="p">(</span><span class="k">const</span> <span class="n">Task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span> <span class="k">const</span> <span class="n">Domain</span> <span class="o">&amp;</span><span class="n">domain</span><span class="p">,</span>
                                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DomainSplit</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">slices</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">all_procs</span> <span class="o">=</span> <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_all_processors</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="n">split_set</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">split_set</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DefaultMapper</span><span class="o">::</span><span class="n">select_random_processor</span><span class="p">(</span>
                        <span class="n">all_procs</span><span class="p">,</span> <span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">,</span> <span class="n">machine</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">DefaultMapper</span><span class="o">::</span><span class="n">decompose_index_space</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">split_set</span><span class="p">,</span> 
                                        <span class="mi">1</span><span class="cm">/*splitting factor*/</span><span class="p">,</span> <span class="n">slices</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DomainSplit</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">slices</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">it</span> <span class="o">!=</span> <span class="n">slices</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">it</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Rect</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">rect</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">domain</span><span class="p">.</span><span class="n">get_rect</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">volume</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">it</span><span class="o">-&gt;</span><span class="n">recurse</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">it</span><span class="o">-&gt;</span><span class="n">recurse</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">map_task</span><span class="p">(</span><span class="n">Task</span> <span class="o">*</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span> 
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vis_mems</span> <span class="o">=</span> 
      <span class="n">machine</span><span class="o">-&gt;</span><span class="n">get_visible_memories</span><span class="p">(</span><span class="n">task</span><span class="o">-&gt;</span><span class="n">target_proc</span><span class="p">);</span>  
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">vis_mems</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">regionssize</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span> <span class="n">mems_copy</span> <span class="o">=</span> <span class="n">vis_mems</span><span class="p">;</span>  
    <span class="c1">// Assign memories in a random order
</span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mems_copy</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">mem_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">lrand48</span><span class="p">()</span> <span class="o">%</span> <span class="n">mems_copy</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">mems_copy</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mem_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">it</span><span class="o">++</span><span class="p">;</span>
      <span class="n">task</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">target_ranking</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">);</span>
      <span class="n">mems_copy</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">task</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">virtual_map</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">task</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">enable_WAR_optimization</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">task</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">reduction_list</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">task</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">blocking_factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// Report successful mapping results
</span>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">AdversarialMapper</span><span class="o">::</span><span class="n">notify_mapping_result</span><span class="p">(</span><span class="k">const</span> <span class="n">Mappable</span> <span class="o">*</span><span class="n">mappable</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mappable</span><span class="o">-&gt;</span><span class="n">get_mappable_kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Mappable</span><span class="o">::</span><span class="n">TASK_MAPPABLE</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">Task</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="n">mappable</span><span class="o">-&gt;</span><span class="n">as_mappable_task</span><span class="p">();</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Mapped region %d of task %s (ID %lld) to memory %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
              <span class="n">idx</span><span class="p">,</span> <span class="n">task</span><span class="o">-&gt;</span><span class="n">variants</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> 
              <span class="n">task</span><span class="o">-&gt;</span><span class="n">get_unique_task_id</span><span class="p">(),</span>
              <span class="n">task</span><span class="o">-&gt;</span><span class="n">regions</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">selected_memory</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">PartitioningMapper</span><span class="o">::</span><span class="n">PartitioningMapper</span><span class="p">(</span><span class="n">Machine</span> <span class="o">*</span><span class="n">m</span><span class="p">,</span>
                                       <span class="n">HighLevelRuntime</span> <span class="o">*</span><span class="n">rt</span><span class="p">,</span>
                                       <span class="n">Processor</span> <span class="n">p</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">DefaultMapper</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">rt</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">PartitioningMapper</span><span class="o">::</span><span class="n">get_tunable_value</span><span class="p">(</span><span class="k">const</span> <span class="n">Task</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
                                          <span class="n">TunableID</span> <span class="n">tid</span><span class="p">,</span>
                                          <span class="n">MappingTagID</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tid</span> <span class="o">==</span> <span class="n">SUBREGION_TUNABLE</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Processor</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">cpu_procs</span> <span class="o">=</span> 
      <span class="n">machine_interface</span><span class="p">.</span><span class="n">filter_processors</span><span class="p">(</span><span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">cpu_procs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">// Should never get here
</span>  <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">HighLevelRuntime</span><span class="o">::</span><span class="n">set_top_level_task_id</span><span class="p">(</span><span class="n">TOP_LEVEL_TASK_ID</span><span class="p">);</span>
  <span class="n">HighLevelRuntime</span><span class="o">::</span><span class="n">register_legion_task</span><span class="o">&lt;</span><span class="n">top_level_task</span><span class="o">&gt;</span><span class="p">(</span><span class="n">TOP_LEVEL_TASK_ID</span><span class="p">,</span>
      <span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*single*/</span><span class="p">,</span> <span class="nb">false</span><span class="cm">/*index*/</span><span class="p">);</span>
  <span class="n">HighLevelRuntime</span><span class="o">::</span><span class="n">register_legion_task</span><span class="o">&lt;</span><span class="n">init_field_task</span><span class="o">&gt;</span><span class="p">(</span><span class="n">INIT_FIELD_TASK_ID</span><span class="p">,</span>
      <span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*single*/</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*index*/</span><span class="p">);</span>
  <span class="n">HighLevelRuntime</span><span class="o">::</span><span class="n">register_legion_task</span><span class="o">&lt;</span><span class="n">daxpy_task</span><span class="o">&gt;</span><span class="p">(</span><span class="n">DAXPY_TASK_ID</span><span class="p">,</span>
      <span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*single*/</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*index*/</span><span class="p">);</span>
  <span class="n">HighLevelRuntime</span><span class="o">::</span><span class="n">register_legion_task</span><span class="o">&lt;</span><span class="n">check_task</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CHECK_TASK_ID</span><span class="p">,</span>
      <span class="n">Processor</span><span class="o">::</span><span class="n">LOC_PROC</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*single*/</span><span class="p">,</span> <span class="nb">true</span><span class="cm">/*index*/</span><span class="p">);</span>

  <span class="c1">// Here is where we register the callback function for 
</span>  <span class="c1">// creating custom mappers.
</span>  <span class="n">HighLevelRuntime</span><span class="o">::</span><span class="n">set_registration_callback</span><span class="p">(</span><span class="n">mapper_registration</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">HighLevelRuntime</span><span class="o">::</span><span class="n">start</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
<span class="p">}</span></pre></td></tr></tbody></table></code></pre></figure>


    </div><!-- /.article-wrap -->
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    <span>&copy; 2017 Legion. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/">Minimal Mistakes</a> theme.</span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl = 
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-20524102-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
          

</body>
</html>