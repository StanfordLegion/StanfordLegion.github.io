<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Realm Barrier &#8211; Legion Programming System</title>
<meta name="description" content="">

<meta name="keywords" content="">


<!-- mermaid Graph -->


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Realm Barrier">
<meta property="og:description" content="Home page for the Legion parallel programming system">
<meta property="og:url" content="/tutorial/realm/barrier.html">
<meta property="og:site_name" content="Legion Programming System">





<link rel="canonical" href="/tutorial/realm/barrier.html">
<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Legion Programming System Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='https://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.min.css">

<!--[if (lt IE 9) & (!IEMobile)]>
<link rel="stylesheet" href="/assets/css/ie.min.css">
<![endif]-->

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<link rel="icon" sizes="16x16" href="/images/favicon/favicon-16x16.png">
<link rel="icon" sizes="32x32" href="/images/favicon/favicon-32x32.png">
<link rel="icon" sizes="48x48" href="/images/favicon/favicon-48x48.png">
<link rel="icon" sizes="96x96" href="/images/favicon/favicon-96x96.png">
<link rel="icon" sizes="144x144" href="/images/favicon/favicon-144x144.png">
<link rel="icon" sizes="192x192" href="/images/favicon/favicon-192x192.png">
<link rel="apple-touch-icon" sizes="57x57" href="/images/favicon/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/images/favicon/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/images/favicon/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/images/favicon/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/images/favicon/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/images/favicon/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/images/favicon/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/images/favicon/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-icon-180x180.png">
<link rel="apple-touch-icon-precomposed" sizes="192x192" href="/images/favicon/apple-icon-precomposed.png">
<meta name="msapplication-config" content="/images/favicon/browserconfig.xml" />
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<link rel="manifest" href="/images/favicon/manifest.json">

</head>

<body class="page" itemscope itemtype="http://schema.org/WebPage">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="/">Legion Programming System</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
		    <ul>
		        
				<li><a href="/overview/" >Overview</a></li>
		        
				<li><a href="/starting/" >Getting Started</a></li>
		        
				<li><a href="/tutorial/" >Tutorials</a></li>
		        
				<li><a href="/events/" >Events</a></li>
		        
				<li><a href="/documentation/" >Documentation</a></li>
		        
				<li><a href="/publications/" >Publications</a></li>
		        
				<li><a href="/resources/" >Resources</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->




<div id="main" role="main"  itemprop="mainContentOfPage">
  <div class="article-author-side">
    <a href="https://www.stanford.edu/"><img src="/images/logos/stanford.png" class="bio-photo" alt="Stanford University logo"></a>
<a href="https://www6.slac.stanford.edu/"><img src="/images/logos/slac.jpg" class="bio-photo" alt="SLAC National Accelerator Laboratory logo"></a>
<a href="https://www.lanl.gov/"><img src="/images/logos/los-alamos.png" class="bio-photo" alt="Los Alamos National Laboratory logo"></a>
<a href="https://www.nvidia.com/"><img src="/images/logos/nvidia.png" class="bio-photo" alt="NVIDIA logo"></a>
<a href="https://www.rdworldonline.com/rd-100-award-winners-announced-in-analytical-test-it-electrical-categories/"><img src="/images/logos/rd100.png" class="bio-photo" alt="Winner of the R&D 100 Award"></a>

<h3>Legion</h3>
<p>A Data-Centric Parallel Programming System</p>





<a href="http://github.com/StanfordLegion/legion" class="author-social" target="_blank"><i class="icon-github"></i> Github</a>



  </div>
  <article itemscope itemtype="http://schema.org/CreativeWork">
    <h1 itemprop="name">Realm Barrier</h1>
    <div class="article-wrap" itemprop="text">
      <h2 id="introduction">Introduction</h2>

<p>A <code class="language-plaintext highlighter-rouge">Barrier</code> is a special kind of <code class="language-plaintext highlighter-rouge">Event</code> (notice that it inherits from the base Event class) that 
requires multiple arrivals in order for it to trigger. Additionally, unlike normal events, 
which only have a single generation, a barrier has multiple generations, named phases. 
Therefore, a barrier can be advanced to the next generation and performed arrivals 
even before the previous generation has been triggered. However, a barrier has to be explicitly destroyed. 
In this example, there are two types of tasks, reader and writer. 
During each iteration, every writer task generates an integer value. Subsequently, 
the collective sum of all these integers is calculated, and the resulting sum is then accessed by the reader tasks. 
Thus, the writer and reader tasks take turns to execute.
We illustrate how to use <code class="language-plaintext highlighter-rouge">Barrier</code> to go back and forth between 
reader and writer tasks of different iterations.</p>

<p>Here is a list of covered topics:</p>

<ul>
  <li><a href="#creating-barriers">Creating Barriers</a></li>
  <li><a href="#creating-reductions">Creating Reductions</a></li>
  <li><a href="#synchronizing-tasks-with-barriers">Synchronizing Tasks with Barriers</a></li>
  <li><a href="#performance-considerations">Performance Considerations</a></li>
  <li><a href="#limitations">Limitations</a></li>
</ul>

<h2 id="creating-barriers">Creating Barriers</h2>

<p>As introduced in the first section, each writer task performs a reduction operation on its local integer value. 
The reader tasks can not read the reduction value until all writer tasks have completed writing. 
This kind of synchronization can be implemented by <code class="language-plaintext highlighter-rouge">Barrier</code>. 
In this example, we need to create two barriers, a <code class="language-plaintext highlighter-rouge">writer_barrier</code> and <code class="language-plaintext highlighter-rouge">reader_barrier</code>,
to synchronize writer and reader tasks, respectively. 
To create a barrier, we need to pass the number of concurrent barrier tasks into the <code class="language-plaintext highlighter-rouge">create_barrier</code> function.
The following code demonstrates creating a <code class="language-plaintext highlighter-rouge">reader_barrier</code>, where we need to pass the number of participants:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Barrier</span> <span class="n">reader_barrier</span> <span class="o">=</span> <span class="n">Barrier</span><span class="o">::</span><span class="n">create_barrier</span><span class="p">(</span><span class="n">TestConfig</span><span class="o">::</span><span class="n">num_readers</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="creating-reductions">Creating Reductions</h2>

<p>The summation operation of writer tasks can be implemented using a reduction,
which is declared as <code class="language-plaintext highlighter-rouge">ReductionOpIntAdd</code>. A reduction operator requires two functions, 
<code class="language-plaintext highlighter-rouge">apply</code> combines a left-hand side type with a right-hand side type into a new left-hand side type, and <code class="language-plaintext highlighter-rouge">fold</code>
combines two right-hand side types into a new right-hand side type, as well as an <code class="language-plaintext highlighter-rouge">identity</code>, a unique integer
for Realm to recognize the reduction. The reduction operator needs to be registered by calling <code class="language-plaintext highlighter-rouge">register_reduction</code>
before launching the main task, shown as follows:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rt</span><span class="p">.</span><span class="n">register_reduction</span><span class="o">&lt;</span><span class="n">ReductionOpIntAdd</span><span class="o">&gt;</span><span class="p">(</span><span class="n">REDOP_ADD</span><span class="p">);</span>
</code></pre></div></div>

<p>The communication pattern of barrier and all reduction are similar; therefore, in the MPI world, these two
routines have similar implementation. 
Inspired by this, Realm extends the barrier to perform all-reduction-like computations, where each task can pass a number to
the barrier. When reaching the synchronization point, the reduction value of all numbers is available to tasks that
hold the barrier. 
To perform reduction with a barrier, we can attach a reduction operator to the <code class="language-plaintext highlighter-rouge">create_barrier</code> function.
The <code class="language-plaintext highlighter-rouge">init_value</code> tells the initial value of the parameter that the reduction operation is performed on.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Barrier</span> <span class="n">writer_barrier</span> <span class="o">=</span> <span class="n">Barrier</span><span class="o">::</span><span class="n">create_barrier</span><span class="p">(</span><span class="n">TestConfig</span><span class="o">::</span><span class="n">num_writers</span><span class="p">,</span> <span class="n">REDOP_ADD</span><span class="p">,</span>
                                                 <span class="o">&amp;</span><span class="n">init_value</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">init_value</span><span class="p">));</span>
</code></pre></div></div>
<p>Later, the result of the reduction can be retrieved by <code class="language-plaintext highlighter-rouge">get_result</code>.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">ready</span> <span class="o">=</span> <span class="n">writer_b</span><span class="p">.</span><span class="n">get_result</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">result</span><span class="p">));</span>
</code></pre></div></div>

<h2 id="synchronizing-tasks-with-barriers">Synchronizing Tasks with Barriers</h2>

<p>The lifetime of a Barrier consists of one or more phases. Each phase of a Barrier defines a synchronization point, 
where blocks of code wait for other tasks to catch up before proceeding. Tasks can arrive at the barrier 
but defer waiting on the phase synchronization point
by calling <code class="language-plaintext highlighter-rouge">arrive</code>. The same or other tasks can later block on the phase synchronization point by calling <code class="language-plaintext highlighter-rouge">wait</code>.
We can utilize the <code class="language-plaintext highlighter-rouge">arrive</code> and <code class="language-plaintext highlighter-rouge">wait</code> to synchronize different tasks.</p>

<p>When a writer finishes work, <code class="language-plaintext highlighter-rouge">arrive</code> is called to inform the runtime that it arrives at 
the synchronization point. 
Since we use reduction to accumulate the integer produced by 
each writer task, each writer task can pass the integer to the <code class="language-plaintext highlighter-rouge">arrive</code> function to perform the reduction.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">writer_b</span><span class="p">.</span><span class="n">arrive</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Event</span><span class="o">::</span><span class="n">NO_EVENT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reduce_val</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">reduce_val</span><span class="p">));</span>
</code></pre></div></div>

<p>On the other side, a reader task calls <code class="language-plaintext highlighter-rouge">wait</code> to wait until all writer tasks finish calling <code class="language-plaintext highlighter-rouge">arrive</code>.
The <code class="language-plaintext highlighter-rouge">wait</code> is blocked until the <code class="language-plaintext highlighter-rouge">arrive</code> is called N times, where the N matches the number used for <code class="language-plaintext highlighter-rouge">create_barrier</code>.
The same mechanism is used by writer tasks to continue working after all reader tasks finish reading.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">writer_b</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
</code></pre></div></div>

<p>When a <code class="language-plaintext highlighter-rouge">Barrier</code> finishes a synchronization point after the <code class="language-plaintext highlighter-rouge">wait</code> is returned, we can call <code class="language-plaintext highlighter-rouge">advance_barrier</code>
to enter the next phase. In the example, we need to synchronize reader/writer tasks multiple times (one time per iteration), 
so after an iteration is done, <code class="language-plaintext highlighter-rouge">advance_barrier</code> is called to go into the next iteration.</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">writer_b</span> <span class="o">=</span> <span class="n">writer_b</span><span class="p">.</span><span class="n">advance_barrier</span><span class="p">();</span>
<span class="n">reader_b</span> <span class="o">=</span> <span class="n">reader_b</span><span class="p">.</span><span class="n">advance_barrier</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="performance-considerations">Performance Considerations</h2>

<p>Even though tasks can be preempted, a Processor can only execute one task at a time. Therefore, to increase
task-level parallelism, it is preferred to launch concurrent tasks onto different Processors. 
In this example, we reverse the first 4 CPU Processors for the main task and the three reader tasks, and then
we vary the number of writer tasks and <code class="language-plaintext highlighter-rouge">-ll:cpu</code> to show how the processor assignment affects the overall performance.</p>

<p>a. Run with 4 writer tasks on the same processor.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./barrier -ll:cpu 5 -nw 4 -ll:force_kthreads
[0 - 7fa670922800]    0.069117 {3}{app}: start top task on Processor 1d00000000000001, tid 3638294
[0 - 7fa66bffe800]    0.069400 {3}{app}: start writer task 0 on Processor 1d00000000000005, tid 3638298
[0 - 7fa67071e800]    0.069436 {3}{app}: start reader task 0 on Processor 1d00000000000002, tid 3638295
[0 - 7fa67051a800]    0.069511 {3}{app}: start reader task 1 on Processor 1d00000000000003, tid 3638296
[0 - 7fa670316800]    0.069530 {3}{app}: start reader task 2 on Processor 1d00000000000004, tid 3638297
[0 - 7fa66b5ea800]    1.070073 {3}{app}: start writer task 1 on Processor 1d00000000000005, tid 3638303
[0 - 7fa66b3e6800]    2.070547 {3}{app}: start writer task 2 on Processor 1d00000000000005, tid 3638304
[0 - 7fa66b1e2800]    3.070931 {3}{app}: start writer task 3 on Processor 1d00000000000005, tid 3638305
...
[0 - 7fce75bec7c0]   16.061451 {3}{app}: Total time 0.165409(s)
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">-ll:force_kthreads</code> force Realm always to use kernel threads (pthread in Linux), even though 4 writer tasks are
dispatched onto different threads; since they belong to the same processor, Realm does not execute them concurrently.</p>

<p>The following is the result without forcing to use kernel threads.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./barrier -ll:cpu 5 -nw 4
[0 - 7f27a0afc800]    0.069120 {3}{app}: start top task on Processor 1d00000000000001, tid 3638275
[0 - 7f27a0098800]    0.069369 {3}{app}: start writer task 0 on Processor 1d00000000000005, tid 3638279
[0 - 7f27a0a68800]    0.069404 {3}{app}: start reader task 0 on Processor 1d00000000000002, tid 3638276
[0 - 7f27a00a4800]    0.069457 {3}{app}: start reader task 2 on Processor 1d00000000000004, tid 3638278
[0 - 7f27a00b0800]    0.069462 {3}{app}: start reader task 1 on Processor 1d00000000000003, tid 3638277
[0 - 7f27a0098800]    1.069763 {3}{app}: start writer task 1 on Processor 1d00000000000005, tid 3638279
[0 - 7f27a0098800]    2.070110 {3}{app}: start writer task 2 on Processor 1d00000000000005, tid 3638279
[0 - 7f27a0098800]    3.070357 {3}{app}: start writer task 3 on Processor 1d00000000000005, tid 3638279
...
[0 - 7fd3d6fa27c0]   16.052200 {3}{app}: Total time 0.165527(s)
</code></pre></div></div>

<p>It is noted that all the writer tasks are running on the same kernel thread, even though Realm create green threads
to minimize the creation and context switch overhead of kernel threads; since all task are launched onto the 
same processor, they can not be parallelized.</p>

<p>b. Run with 4 writer tasks on different processors.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./barrier -ll:cpu 8 -nw 4
[0 - 7f4dc9f44800]    0.069260 {3}{app}: start top task on Processor 1d00000000000001, tid 3638318
[0 - 7f4dc80d1800]    0.069490 {3}{app}: start writer task 0 on Processor 1d00000000000005, tid 3638322
[0 - 7f4dc80b9800]    0.069533 {3}{app}: start writer task 2 on Processor 1d00000000000007, tid 3638324
[0 - 7f4dc80c5800]    0.069560 {3}{app}: start writer task 1 on Processor 1d00000000000006, tid 3638323
[0 - 7f4dc80e9800]    0.069596 {3}{app}: start reader task 1 on Processor 1d00000000000003, tid 3638320
[0 - 7f4dc80dd800]    0.069607 {3}{app}: start reader task 2 on Processor 1d00000000000004, tid 3638321
[0 - 7f4dc9eb0800]    0.069593 {3}{app}: start reader task 0 on Processor 1d00000000000002, tid 3638319
[0 - 7f4dc80ad800]    0.069596 {3}{app}: start writer task 3 on Processor 1d00000000000008, tid 3638325
...
[0 - 7faf67fe97c0]    4.065398 {3}{app}: Total time 0.042038(s)
</code></pre></div></div>

<p>All writer tasks occupy different processors, so we achieve 4x speedup over the previous configuration.</p>

<h2 id="limitations">Limitations</h2>

<p>There are two limitations when using barriers:</p>

<ul>
  <li>A barrier has a maximum number of phases/generations, defined as <code class="language-plaintext highlighter-rouge">MAX_PHASES</code>. If a barrier is advanced past its last phase
then <code class="language-plaintext highlighter-rouge">advance_barrier</code> returns <code class="language-plaintext highlighter-rouge">NO_BARRIER</code>.</li>
  <li>A barrierâ€™s phases/generations must be triggered in order. So you might advance to the next generation of a barrier and 
start doing arrivals on it without arriving on the previous generation. Even if all the arrivals for this next generation
have been performed, the generation will not trigger because the previous generation has not triggered. For example,
the following code leads to deadlock because one generation is skipped in each loop.</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">barrier</span><span class="p">.</span><span class="n">arrive</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">barrier</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
  <span class="n">barrier</span> <span class="o">=</span> <span class="n">barrier</span><span class="p">.</span><span class="n">advance_barrier</span><span class="p">();</span>
  <span class="n">barrier</span> <span class="o">=</span> <span class="n">barrier</span><span class="p">.</span><span class="n">advance_barrier</span><span class="p">();</span> <span class="c1">// this generation is ignored.</span>
<span class="p">}</span>
</code></pre></div></div>

    </div><!-- /.article-wrap -->
  </article>
</div><!-- /#index -->

<div class="footer-wrap">
  <footer>
    <span>&copy; 2023 Legion. Powered by <a href="http://jekyllrb.com">Jekyll</a> using the <a href="http://mademistakes.com/">Minimal Mistakes</a> theme.</span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="/assets/js/scripts.min.js"></script>

<!-- Asynchronous Google Analytics snippet -->
<script>
  var _gaq = _gaq || [];
  var pluginUrl = 
 '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-20524102-3']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

          

</body>
</html>
